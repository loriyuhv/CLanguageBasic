# 指针

## 1 指针的分类

### 1.1 基本类型指针

#### 1.1.1 指针变量的定义及初始化

```C
#include<stdio.h>
int main()
{
	int* p;
	int i = 3;
	p = &i;
	printf("i的地址：%x, %p\n", &i, &i);
	printf("p的值,也就是i的地址：%p\n", p);
	printf("i的值：%d\n", *p);
	return 0;
}
```

```C
int* p;	/*定义了一个指针变量p*/
```

- p是变量的名字，int* 表示p变量存放的是int类型变量的地址。
- int* p 不是表示定义了一个名字叫做*p的变量。
- int* p 应该这样理解：p是变量名，p变量的数据类型是``int*``类型，所谓```int*``` 类型实际就是存放int变量地址的类型。

```C
p = &i; /*为指针变量赋值，即初始化。*/
```

- p保存了i的地址，因此p指向i。
- p不是i, i也不是p. 更准确的说：修改p的值不影响i的值，修改i的值也不会影响p的值。
- 如果一个指针变量指向了某个普通变量，则```*指针变量``` 就完全等同于``` 普通变量```  *p = i。

 **例子：**
		如果p是个指针变量，并且p存放了普通变量i的地址，则p指向了普通变量，```*p``` 就完全等同于 i。或者说：在所有出现```*p```的地方都可以替换成i，在所有出现i的地方都可以替换成```*p```。

#### 1.1.2 基本类型指针常见错误分析

```C
#include<stdio.h>
int main() {
	int i = 5, * p = &i, * q;
	//*q = p;	/*error1 语法编译会出错*/
	//*q = *p;	/*error2 使用了未初始化的内存q*/
	//p = q;	/*error3 q是垃圾值，q赋给p，p也变成垃圾值*/
	
	// 改进
	q = p;
	printf("%d\n", *q); /*13行*/
	return 0;
}
```

**错误1**

```C
int i = 5, * p = &i, * q;
*q = p;
printf("%d\n", *q); /*13行*/
```

```int``` 和 ```int *```的间接级别不同。由于p存放的值是地址，而*q的值是普通的数值，

**错误2**

```C
int i = 5, * p = &i, * q;
*q = *p;
printf("%d", *q); /*13行*/
```

使用了未初始化的内存q，所以q存放的是垃圾值。

**错误3**

```C
int i = 5, * p = &i, * q;
p = q;
printf("%d", *q); /*13行*/
```

q的空间是属于本程序的，所以本程序可以读写q的内容，但是如果q内部是垃圾值，则本程序不能读写*p的内容，因为*q所代表的内存单元的控制权限并没有分配给本程序，运行到13行时就会立即报错。

**改进**

```C
int i = 5, * p = &i, * q;
q = p;
printf("%d", *q); /*13行*/
```



#### 1.1.3 经典指针程序_互换两个数字

**例1**

```C
#include<stdio.h>
int main() {
	int a = 3, b = 5, t;
    t = a, a = b, b = t;
	printf("a = %d, b = %d\n", a, b);
	return 0;
}
```

**例2**

 问：为什么最后没有交换

```C
#include<stdio.h>
void swap(int a, int b) {
	int t;
	t = a, a = b, b = t;
	return;
}
// 注意，当函数调用完成之后会自动释放

int main() {
	int a = 3, b = 5, t;
	swap(a, b);
	printf("a = %d, b = %d\n", a, b);
	return 0;
}
```

因为最终交换的是函数里的形参a, b，函数调用完成之后会自动释放，所以实参a，b的值不会被改变。

**例3**

```C
#include<stdio.h>

void swap(int* a, int* b);

int main() {
	int a = 3, b = 5;
	swap(&a, &b);
    printf("a = %d, b= %d\n", a, b);
	return 0;
}
```

**错误1**

```C
void swap(int* a, int* b) {
	int t;
	t = a, a = b, b = t;
    return;
}
```

因为a，b是指针变量，而t是普通变量，间接引用不同，所以会报错。

**错误2**

```C
void swap(int* a, int* b) {
	int* t;
	t = a, a = b, b = t;
	return;
}
```

- 这里互换的是a, b的值；
- 为什么改变的不是实参a, b的值，因为实参a，b是局部变量，程序加载时就已经分配好了地址；

**改进**

```C
void swap(int* a, int* b) {
	int t;
	t = *a, * a = *b, * b = t;
	return;
}
```

**注意：**要交换实参a, b的值，一定要交换实参a, b。

#### 1.1.4  `*`的含义

1. 乘法

2. 定义指针变量

   - ```C
     int* p; /*定义了一个名字叫p的变量*/
     ```

   - int* 表示p只能存放整型变量的地址。

3. ​	指针运算符

   - 该运算符放在已经定义好的指针变量。如果p是一个已经定义好的指针变量，则*p表示以p的内容为地址的变量

#### 1.4.5 指针使函数返回一个以上的值

```C
#include<stdio.h>

void GetElem(int* e, int* e2) {
	*e = 2;
	*e2 = 3;
	return;
}

int main() {
	int e, e2;
	GetElem(&e, &e2);
	printf("e = %d, e2 = %d\n", e, e2);
	return 0;
}
// 
	// 1）
	// 2）
	// 3）
```

如何通过被调函数修改主调函数普通变量的值

- 实参必须为该普通变量的地址
- 形参必须为指针变量
- 在被调函数中通过`*形参名` = ...的方式就可以修改主调函数相关变量的值。

















